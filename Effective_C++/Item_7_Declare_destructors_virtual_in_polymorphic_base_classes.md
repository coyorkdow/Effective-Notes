# 条款7: 为多态基类声明virtual析构函数

这一条款是至关重要的，因此我打算不吝笔墨做详细介绍。

首先来复习一下C++的多态。用一个基类的指针（或引用）指向一个派生类的实例，并且我们希望藉由基类指针的调用表现的和派生类一致。`Base`类定义了方法`DoSth()`，继承了`Base`的派生类`Derived`对方法`DoSth()`有着和基类不同的实现。指向	`Derived`实例的`Base`指针`bPtr`应该调用`Derived`的`DoSth()`实现，而非`Base`的。

从内存模型来看，调用类方法和调用一般的函数没有区别，每一个类方法的定义对应了唯一的函数入口地址。如果`DoSth()`没有被声明为`virtual`，那么在执行`bPtr->Dosth()`时，编译器知道`Base`类的`DoSth()`定义，于是生成了call指令让程序跳转到它的入口地址，就和编译一般的函数调用的代码一模一样。唯一的区别是调用方法的实例的地址也会作为隐式地作为函数参数传递，这就是`this`指针。就如以下指令所示。

```
->  0x100003a6d <+34>:  movq   -0x18(%rbp), %rax
    0x100003a71 <+38>:  movq   %rax, %rdi
    0x100003a74 <+41>:  callq  0x100003b3a               ; symbol stub for: Base::DoSth()
```

看起来，实现多态的任务是要让编译器知道执行`bPtr->Dosth()`时，实际执行的究竟是`Base`类的`DoSth()`定义还是`Derived`类的`DoSth()`定义。这需要提前知道指针指向的究竟是基类还是派生类，但这基本是一个不可能完成的事情，就连拥有人类智慧的程序员也无从下手。因此我们只能放弃在编译时就知道对应的函数入口地址并直接生成代码的想法，退而把这一工作在程序运行时完成。

通过vptr（virtual table pointer, 虚表指针）可以做到这一点。具有`virtual`方法（或者说，虚函数）的类实例自身会携带一个叫vptr的指针，它通常位于对象的头部，它指向了一个存储了虚函数地址的数组，即虚表。每一个具有虚函数的类都对应了这样一个虚表，`Base`类和`Derived`类都各自有一个不同的虚表，里面存储有各自的`DoSth()`实现的地址。编译器在处理虚函数的调用时会做特殊处理，不是直接生成调用某个函数的代码，而是先访问对象的vptr所指的虚表，再从中获得需要访问的函数的入口地址。在执行`bPtr->Dosth()`时，尽管`bPtr`是一个`Base`指针，但是因为它指向的实例是`Derived`的，因此vptr指向了`Derived`的虚表，于是程序运行了`Derived`对`DoSth()`的实现。下面的代码展示了一次调用虚函数`Dosth()`的过程，和上面的非虚函数调用不同的是，程序先取对象中的vptr访问虚表（+34和+38），再从虚表中取出函数入口地址放入寄存器rdx（+41），最后call指令的操作数正是寄存器rdx中的值。

```
->  0x100003a67 <+34>:  movq   -0x18(%rbp), %rax
    0x100003a6b <+38>:  movq   (%rax), %rax
    0x100003a6e <+41>:  movq   (%rax), %rdx
    0x100003a71 <+44>:  movq   -0x18(%rbp), %rax
    0x100003a75 <+48>:  movq   %rax, %rdi
    0x100003a78 <+51>:  callq  *%rdx
```

关于虚函数和vptr有一条关键规则：一个类的虚函数性质会延续到继承它的类。当一个类继承了基类时，它也从基类继承了一份虚表，里面是所有虚函数的入口地址。如果它自己实现了某个虚函数，那么就在虚表中用自己的实现替换掉基类的。如果有的虚函数没有实现，那么通过派生类实例访问到的仍然是基类的版本。同样的，派生类可以定义自己的而非继承自基类的虚函数，这将是基类的虚表中没有的条目。如果`Base`定义了方法`DoSth2()`但是没有声明为`virtual`，那么再在`Derived`中定义`DoSth2()`就是一个和基类完全无关的新的函数。我们可以把`Derived`中定义的`DoSth2()`声明为`virtual`，这样`Derived`和它的派生类们都会用虚函数的规则处理`DoSth2()`。但是用`Base`指针调用`DoSth2()`却永远不会进入`Derived`以及更之后的继承中的实现，因为对于`Base`来说`DoSth2()`是非虚的。

铺垫了这么多，现在终于可以步入正题了。析构函数较之其它类方法有一个特殊之处，即如果一个派生类的析构函数被调用，那么程序会自下而上依次调用所有祖先类的析构函数。可以这样概括，析构函数会沿着继承关系的反方向链式调用。实现这样的逻辑很简单，编译器只需要在每一个类的析构函数定义中调用它继承的类的析构函数即可。

有时候我们需要通过一个基类指针释放派生类实例的资源，这时`delete`基类指针应该有和`delete`派生类指针相同的表现，将析构函数声明为`virtual`可以确保这一点。考虑一条继承链，链头部的类具有虚析构函数，于是自它往下，所有的类指针在被`delete`时，都要从虚表中找到对应的析构函数入口地址。如果某一个派生类定义了自己的析构函数，那么它的入口地址会被装填到这个类的虚表中，同时这个析构函数中会隐含继承链上一级的析构函数的调用。于是无论是继承链上游的哪一级指针，都能正确地释放下游的类实例资源。下面的代码演示了一条继承链。值得注意的是被用来作为起点的`A`实际上还继承了没有虚析构函数的基类`Base`，因此通过`Base`的指针无法正确释放下游类实例的资源。这意味着我们应该尽量避免继承析构函数非虚的类，如果一定要这样做，那么不可用它的指针来释放资源。

还有一个需要注意的地方是，我们可以声明一个析构函数是纯虚的(pure virtual)，但是仍然需要给出它的定义。因为析构函数会向上链式调用，而且不会因为遇到了纯虚析构函数就停止这样做。

```c++
class A : public Base /* Base的析构函数是非虚的 */ {
 public:
  virtual ~A(); // 声明为虚析构函数, 隐含了对～Base()的调用
};

class B : public A {
 public:
  ~B(); // 隐含了对～A()的调用
};

class C : public B {
 public:
  ~C(); // 隐含了对～B()的调用
};

A* ptrA = new C;
delete ptrA; // 找到～C()的入口地址，链式调用~C() -> ~B() -> ~A() -> ~Base()
ptrA = new B;
delete ptrA; // 找到～B()的入口地址，链式调用~B() -> ~A() -> ~Base()
Base* ptrBase = new C;
delete Base; // 只会调用～Base()
```