# 条款4: 确保对象被使用前已被初始化

任何对象在使用之前都建议显示初始化，而不要依赖默认的初始化。如果不显示初始化，那么对象的初始化何时一定发生而何时不一定的规则是极其繁琐的，本书也没有对这种规则进行详细介绍。

类的初始化顺序总是固定的。对于派生类来说，基类总是先于自身被初始化；而类成员总是以其被声明的顺序初始化，且初始化的时间早于进入类的构造函数。我们知道类成员的初始化应该用初始化列表(member initialization list)，成员变量在列表中的顺序应该和声明的顺序一致，不然容易导致误解，因为初始化的顺序只取决于声明的顺序。

对于静态对象来说，在不同翻译单元中的外部链接性的静态变量的初始化顺序是无法确定的。如果这个静态对象是类模板中的静态成员，那么即使在相同的翻译单元内也难以确定初始化顺序。毕竟，这个静态成员要靠模板实例化来生成。如果有什么静态变量的初始化存在顺序依赖，那么最好用一个函数来包裹它。对于这样局部作用域的静态变量，它会在程序第一次进入这个函数的时候被初始化。

```c++
Obj& GetObj() {
  static Obj o;
  return o;
}
```

还需要注意的是，非`const`的静态变量不是线程安全的，这是它所具有的静态存储期决定的，和作用域无关。希望你已经明白了作用域和存储期是不同的两个概念！

---
**注:** 本书原文中其实没有提到过类模板中的静态成员的情况，但是我在写`name_of`的时候遇到了（代码见[.../magic/name_of.h](https://github.com/coyorkdow/magic/blob/main/name_of.h)）。一开始我的设计是希望`TypeInfo`直接把各种类型信息定义为`static const`成员，然后就遇到了初始化的顺序依赖问题。现在的方案是在`TypeInfo`中嵌套`Any`的实现，它们的虚函数正是对静态变量的包裹。