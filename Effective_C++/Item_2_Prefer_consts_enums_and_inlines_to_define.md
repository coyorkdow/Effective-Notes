# 条款2: 尽量以const, enum, inline替换#define

`#define`定义了宏，宏会在预处理期完成替换。在编译期时，编译器来看到的已经是替换后的代码文本，因此也不会为宏定义的常量生成符号。同理，C++的作用域也对宏不适用，因为这是编译期的概念：宏仅存在于预处理期。

使用宏定义的常量几乎都可以直接用`const`替换，即使宏定义在头文件中：因为`const`修饰的非`volatile`，没有`extern`修饰的位于命名空间作用域（文件作用域是顶级命名空间作用域）的变量具有内部链接性，因此头文件被多个翻译单元包含也不会有符号冲突。

在绝大多数情况下，强烈建议用`inline`（`inline`修饰的函数的定义可以在每个翻译单元中都出现一次）代替宏以实现内联函数。因为宏做的事情是简单的展开和替换，所以形如以下的宏

```c++
#define MAX((a) > (b) ? (a) : (b))
```

在施以类似`MAX(a++, b)`的表达式时会造成灾难性的后果。

如果想要定义一个类作用域中的常量，通常会使用`static const`的修饰词。然而反直觉的是，形如下面的代码仅声明了类成员`size`，而不是定义。即使已经为它设置了值。

```c++
class A {
  static const int size = 10;
};
```

`static const`修饰的类成员变量的定义必须放在类定义之外。

```c++
const int A::size;
```

---
注1: C++对于非ODR使用(ODR-used)允许变量没有定义，因为非ODR使用不会涉及到变量的地址。虽然看起来在使用常量的场合基本上是不需要考虑地址的，但是一旦涉及到引用就完全不一样了。

注2: 本条款中其实还提及到enum hack的技术，旧的编译器可能不允许`static`成员在声明时得到初始值，因此换以用`enum { size = 5; }`。枚举成员一定是一个编译期常量，因此旧的C++中，enum hack常常在模板元编程中出现，但是从`c++11`开始有了`constexpr`，因此enum hack可以说是过时的技术了。此外`const`修饰的变量也可能是一个编译期常量，所以`static const`也可以用于模板元编程。